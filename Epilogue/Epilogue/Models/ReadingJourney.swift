import Foundation
import SwiftData
import SwiftUI

// MARK: - Reading Journey
/// A personalized reading timeline that helps users accomplish their reading goals
/// without feeling performative or metric-driven. Think "gentle companion" not "Strava for books."
@Model
final class ReadingJourney {
    var id: UUID = UUID()
    var createdAt: Date = Date()
    var updatedAt: Date = Date()

    // User's stated goals from ambient conversation
    var userIntent: String? // "I want to read more classics", "Looking for something lighter"
    var timeframe: String? // "this month", "this season", "by end of year"
    var readingPreference: String? // Morning, evening, weekends, etc.

    // Journey status
    var isActive: Bool = true
    var isPaused: Bool = false
    var pausedReason: String? // "Life gets busy" - no judgment

    // Relationships
    @Relationship(deleteRule: .cascade, inverse: \JourneyBook.journey)
    var books: [JourneyBook]?

    @Relationship(deleteRule: .cascade, inverse: \JourneyMilestone.journey)
    var milestones: [JourneyMilestone]?

    // Adaptive insights
    var lastCheckIn: Date?
    var nextCheckInSuggested: Date?
    var adaptationReason: String? // Why timeline was adjusted

    init(userIntent: String? = nil, timeframe: String? = nil) {
        self.id = UUID()
        self.createdAt = Date()
        self.updatedAt = Date()
        self.userIntent = userIntent
        self.timeframe = timeframe
        self.isActive = true
        self.isPaused = false
    }

    // MARK: - Computed Properties

    var orderedBooks: [JourneyBook] {
        (books ?? []).sorted { $0.order < $1.order }
    }

    var currentBook: JourneyBook? {
        orderedBooks.first { !$0.isCompleted }
    }

    var completedBooks: [JourneyBook] {
        orderedBooks.filter { $0.isCompleted }
    }

    var upcomingBooks: [JourneyBook] {
        orderedBooks.filter { !$0.isCompleted && !$0.isCurrentlyReading }
    }

    var progress: Double {
        guard let books = books, !books.isEmpty else { return 0 }
        let completed = books.filter { $0.isCompleted }.count
        return Double(completed) / Double(books.count)
    }

    // MARK: - Journey Management

    func addBook(_ book: BookModel, reasoning: String? = nil) {
        let journeyBook = JourneyBook(
            bookModel: book,
            journey: self,
            order: (books?.count ?? 0),
            reasoning: reasoning
        )

        if books == nil {
            books = []
        }
        books?.append(journeyBook)
        updatedAt = Date()
    }

    func removeBook(_ journeyBook: JourneyBook) {
        books?.removeAll { $0.id == journeyBook.id }
        // Reorder remaining books
        reorderBooks()
        updatedAt = Date()
    }

    func reorderBooks() {
        guard let books = books else { return }
        for (index, book) in books.enumerated() {
            book.order = index
        }
        updatedAt = Date()
    }

    func pause(reason: String) {
        isPaused = true
        pausedReason = reason
        updatedAt = Date()
    }

    func resume() {
        isPaused = false
        pausedReason = nil
        updatedAt = Date()
    }

    func adjustTimeline(reason: String) {
        adaptationReason = reason
        updatedAt = Date()
        // Timeline will be regenerated by Foundation Models
    }
}

// MARK: - Journey Book
/// Represents a book within the reading journey with its position and status
@Model
final class JourneyBook {
    var id: UUID = UUID()
    var order: Int = 0 // Position in the journey

    // Relationship to the actual book
    var bookModel: BookModel?
    var journey: ReadingJourney?

    // Journey-specific metadata
    var addedAt: Date = Date()
    var reasoning: String? // Why this book is in this position
    var estimatedDuration: String? // "2 weeks", "a month" - natural language
    var suggestedStartDate: Date?
    var targetCompletionDate: Date?

    // Status
    var isCurrentlyReading: Bool = false
    var isCompleted: Bool = false
    var completedAt: Date?
    var wasSkipped: Bool = false
    var skipReason: String? // No judgment - "mood changed", "not the right time"

    // Milestones for this book
    @Relationship(deleteRule: .cascade, inverse: \BookMilestone.journeyBook)
    var milestones: [BookMilestone]?

    init(bookModel: BookModel, journey: ReadingJourney, order: Int, reasoning: String? = nil) {
        self.id = UUID()
        self.bookModel = bookModel
        self.journey = journey
        self.order = order
        self.reasoning = reasoning
        self.addedAt = Date()
        self.isCurrentlyReading = (order == 0) // First book is current by default
    }

    // MARK: - Computed Properties

    var orderedMilestones: [BookMilestone] {
        (milestones ?? []).sorted { $0.order < $1.order }
    }

    var currentMilestone: BookMilestone? {
        orderedMilestones.first { !$0.isCompleted }
    }

    var progress: Double {
        guard let milestones = milestones, !milestones.isEmpty else { return 0 }
        let completed = milestones.filter { $0.isCompleted }.count
        return Double(completed) / Double(milestones.count)
    }

    // MARK: - Book Management

    func addMilestone(_ milestone: BookMilestone) {
        if milestones == nil {
            milestones = []
        }
        milestone.journeyBook = self
        milestones?.append(milestone)
    }

    func markAsCompleted() {
        isCompleted = true
        isCurrentlyReading = false
        completedAt = Date()

        // Mark all milestones as completed
        milestones?.forEach { $0.isCompleted = true }
    }

    func startReading() {
        isCurrentlyReading = true
    }

    func skip(reason: String) {
        wasSkipped = true
        skipReason = reason
        isCurrentlyReading = false
    }
}

// MARK: - Journey Milestone
/// Major waypoints in the overall reading journey (completing books, seasonal breaks, etc.)
@Model
final class JourneyMilestone {
    var id: UUID = UUID()
    var title: String = ""
    var description: String?
    var milestoneType: String = MilestoneType.bookCompletion.rawValue
    var order: Int = 0

    var journey: ReadingJourney?

    // Timing
    var estimatedDate: Date?
    var completedAt: Date?
    var isCompleted: Bool = false

    // Reflection
    var reflectionPrompt: String? // Generated by Foundation Models
    var userReflection: String? // User's response

    init(title: String, type: MilestoneType, order: Int) {
        self.id = UUID()
        self.title = title
        self.milestoneType = type.rawValue
        self.order = order
    }
}

// MARK: - Book Milestone
/// Meaningful markers within a book (not page numbers - chapters, parts, turning points)
@Model
final class BookMilestone {
    var id: UUID = UUID()
    var title: String = ""
    var description: String? // "Part 1: The Fellowship Forms", "The turning point"
    var order: Int = 0

    var journeyBook: JourneyBook?

    // Milestone metadata
    var milestoneType: String = BookMilestoneType.chapter.rawValue
    var chapterNumber: Int?
    var pageNumber: Int? // Optional - for reference only, not strict tracking

    // Status
    var isCompleted: Bool = false
    var completedAt: Date?

    // Reflection
    var reflectionPrompt: String? // "What did you think of the reveal?"
    var userReflection: String?

    init(title: String, type: BookMilestoneType, order: Int) {
        self.id = UUID()
        self.title = title
        self.milestoneType = type.rawValue
        self.order = order
    }

    var type: BookMilestoneType {
        BookMilestoneType(rawValue: milestoneType) ?? .custom
    }
}

// MARK: - Supporting Types

enum MilestoneType: String, Codable, CaseIterable {
    case bookCompletion = "Book Completion"
    case seasonalBreak = "Seasonal Break"
    case reflectionPoint = "Reflection Point"
    case halfway = "Halfway"
    case custom = "Custom"

    var icon: String {
        switch self {
        case .bookCompletion: return "checkmark.circle.fill"
        case .seasonalBreak: return "moon.stars.fill"
        case .reflectionPoint: return "bubble.left.fill"
        case .halfway: return "flag.fill"
        case .custom: return "star.fill"
        }
    }
}

enum BookMilestoneType: String, Codable, CaseIterable {
    case chapter = "Chapter"
    case part = "Part"
    case section = "Section"
    case turningPoint = "Turning Point"
    case climax = "Climax"
    case custom = "Custom"

    var icon: String {
        switch self {
        case .chapter: return "book.pages"
        case .part: return "book.closed"
        case .section: return "doc.text"
        case .turningPoint: return "arrow.triangle.turn.up.right.circle"
        case .climax: return "bolt.fill"
        case .custom: return "circle"
        }
    }
}
